// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Publishing the supported interface; this is what ERC165 is
// A contract that complies with ERC165 defines the following function
// InterfaceID for the following interface is 0x01ffc9a7 as derived from bytes4(keccak256('supportsInterface(bytes4)'));

interface IERC165 {
    /// @notice A contract can query another contract containing this function, passing an interface id
    // to see if that contract supports a given interface.
    /// @param interfaceID The 4byte interface id generated by XORing all function signatures in an interface
    /// @dev Interface identification is specified in ERC-165; this function uses < 30,000 gas units
    /// @return `true` if contract implements an interfce with given `interfaceID` which ID 
    /// is not 0xffffffff (i.e., a null address), `false` otherwise
    function supportsInterface( bytes4 interfaceID) external view returns (bool);
}

// Calculating an interface identifier
// Since only function signatures are enough to calculate it, we can calculate it just from the interface as well

interface Simpson {
    function is2D() external returns (bool);
    function skinColor() external returns (string);
}

contract Lisa is Simpson, ERC165 {
    // Mapping that stores all suported interfaces against a bool
    mapping (bytes4 => bool) internal supportedInterfaces;

    constructor() {
        // Showing that we implement the interface represented by the generate interfaceID 
        supportedInterfaces[this.is2D.selector ^ this.skinColor.selector] = true;
    }
    
    
    /// @dev Generating the interface by XORing the function selectors
    function generateInterfaceID() public pure returns (bytes4) {
        /// @dev Making a variable of type DemoInterface 
        Simpson d;
        /// @dev Calculating and returning the interface id
        return d.is2D.selector ^ d.skinColor.selector;
    }

    /// @dev Generating the function selectors, and XORing them to caclulate the interface Id
    function generateInterfaceIDManual() public pure returns (bytes4) {
        return bytes4(keccak256("is2D()")) ^
               bytes4(keccak256("skinColor()"));
    }

    /// @dev Other contracts will call this function passing in an interfaceID to see if this
    /// contract implements an interface or not.
    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {
        return supportedInterfaces[_interfaceID];
    }

    function is2D() external pure returns (bool) {
        return "foo";
    }

    function bar() external pure returns (string) {
        return "Yellow";
    }
}



// Now, Contract A implements ERC165 interface and thus has a supportaInterface function.
// How does contract B verify if contract A implements a given interface?
// Contract B wil make a STATICCALL to supportsInterface function of Contract A
// it must must be noted that using the STATICCALL opcode is only possible in inline assembly language 

contract B {
    function checkInterfaceImplementation(address _contract, bytes4 _interfaceID,) view internal returns (uint256 success, uint 256 result) {
        // Now, we make a pure function call to the other contract's supportsInterface function passing it an interfaceID
        // We will check if it implements ERC165 interface
        assembly {
            // mload loads/ reads the 32 bytes of memory starting at the 0x40 memory location
            // the 0x40 memory slot is a special part of memory that contains the "free memory pointer"
            // This pointer points the end of the currently allocated memory i.e. new place for us to store sth
            // reserving free memory space in x
            let x := mload(0x40)
            // Storing the ERC165 interfaceID at the beginning of the empty mem storage
            mstore(x, 0x01ffc9a7)

            // _interfaceID here is the interfaceId of the interface we want to know if it is implemented
            // add(memAddressOfx, bytes to add to it (length of interfaceID), then store interfaceID there)
            // mstore (location, data to store at location)
            // location here is memlocation of x + 4 bytes
            mstore(add(x, 0x04), _interfaceID)

            success := staticcall(
                // 30000 gas for the staticcall
                                30000,
                // The contract to whom the call is being made
                                _contract,
                // pointer to the interfaceID of any given interface
                                x,
                                0x24,
                // Storing output over the input to conserve space
                                x,
                                0x20)
            // mload returns the value stored at mam address x, in this case the bool return value of the supportsInterface of ContractA
            result := mload(x) // Finally, loading the result
        }
    }
}

